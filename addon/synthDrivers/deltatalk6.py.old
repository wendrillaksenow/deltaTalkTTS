import synthDriverHandler
from synthDriverHandler import SynthDriver, VoiceInfo, synthIndexReached, synthDoneSpeaking
import speech
import ctypes
from ctypes import *
import os.path
import threading
import time
from collections import OrderedDict
import _thread
from logHandler import log
import logging

from speech.commands import (
	IndexCommand,
	PitchCommand,
	RateCommand,
	VolumeCommand,
)

class SynthDriver(synthDriverHandler.SynthDriver):
	name = "deltatalk"
	description = _("DeltaTalk")

	# Constantes de vozes do sintetizador
	VOICE_MASC1 = 0
	VOICE_MASC2 = 1
	VOICE_FEM1 = 2

	# Constantes DSP_Freq
	DSP_MULTIMEDIA = 0  # Corrigido para corresponder ao valor em DTalk32.h
	DSP_TELEPHONY = 1

	# Constantes de vozes e prosódia
	MODEL_NORMAL = 0
	MODEL_HHS = 1

	EMP_NORMAL = 0
	EMP_STRESS = 1

	# Códigos de erro
	TTS_SUCCESSFUL = 0
	TTS_NOT_INITIALIZED = -1
	TTS_BUSY = -2
	TTS_BAD_COMMAND = -3
	TTS_DSP_INIT_ERROR = -4
	TTS_FILE_OPEN_ERROR = -5
	TTS_FILE_WRITE_ERROR = -6
	TTS_INIT_ENGINE_ERROR = -7
	TTS_MEM_ALLOC_ERROR = -8
	TTS_WAVEOUT_BUSY = -9
	TTS_WAVEOUT_OPEN_ERROR = -10
	TTS_WAVEOUT_WRITE_ERROR = -11
	TTS_WAVEOUT_FORMAT_ERROR = -12
	TTS_WAVEOUT_NOT_AVAILABLE = -13
	TTS_WAVEOUT_ERROR = -14
	TTS_WAVEOUT_MEM_ALLOC_ERROR = -15
	TTS_VALUE_OUT_OF_RANGE = -16
	TTS_PCM_FINISHED = -17
	TTS_MBR_ERROR = -100
	TTS_DSP_NOT_FOUND = -103
	TTS_PROSODY_INIT_ERROR = -104
	TTS_NO_LICENSE = -106

	_voices = OrderedDict()
	_voices["VOICE_MASC1"] = {"name": "DeltaTalk - Marcelo (16 kHz)", "index": VOICE_MASC1}
	_voices["VOICE_MASC2"] = {"name": "DeltaTalk - José (22 kHz)", "index": VOICE_MASC2}
	_voices["VOICE_FEM1"] = {"name": "DeltaTalk - Paula (22 kHz)", "index": VOICE_FEM1}

	instancia = 0

	@classmethod
	def check(cls):
		dtPath = os.path.join(os.path.dirname(__file__), 'deltatalk\\Dtalk32t.dll')
		logging.debug(f"DeltaTalk DLL Path: {dtPath}")
		exists = os.path.exists(dtPath)
		logging.debug(f"DeltaTalk DLL Exists: {exists}")
		return exists

	supportedSettings = [
		SynthDriver.PitchSetting(),
		SynthDriver.RateSetting(),
		SynthDriver.VolumeSetting(),
		SynthDriver.VoiceSetting(),
	]

	supportedCommands = {
		IndexCommand,
		PitchCommand,
		RateCommand,
		VolumeCommand,
	}

	supportedNotifications = {synthIndexReached, synthDoneSpeaking}

	def __init__(self):
	#	super(SynthDriver, self).__init__()
		self._rate = 10
		self._pitch = 10
		self._volume = 20
		self._voice = self.VOICE_MASC1
		self._lastIndex = 0
	#	self.instancia = self.dt.TTSENG_Init()
	#	if self.instancia < 0:
	#		raise RuntimeError(f"Falha ao inicializar DeltaTalk TTS. Código de erro: {self.instancia}")

		dtPath = os.path.join(os.path.dirname(__file__), 'deltatalk\Dtalk32t.dll')
		if not os.path.exists(dtPath):
			raise RuntimeError("DeltaTalk DLL não encontrada no caminho especificado.")
		logging.debug(f"DeltaTalk DLL encontrada no caminho: {dtPath}")

		try:
			self.dt = ctypes.windll.LoadLibrary(dtPath)
			logging.debug(f"DeltaTalk DLL carregada: {self.dt}")

			# Definindo protótipos e parâmetros para as funções da DLL
			self.dt.TTSENG_SetLicense.argtypes = [c_char_p]
			self.dt.TTSENG_SetLicense.restype = c_int

			self.dt.TTSENG_Init.argtypes = [c_bool, c_void_p, c_int]
			self.dt.TTSENG_Init.restype = c_int

			self.dt.TTSENG_InitEx.argtypes = [c_bool, c_void_p, c_int, c_char_p]
			self.dt.TTSENG_InitEx.restype = c_int

			self.dt.TTSENG_Close.argtypes = [c_int]
			self.dt.TTSENG_Close.restype = c_int

			self.dt.TTSENG_GetMode.argtypes = [c_int, POINTER(c_int), POINTER(c_int), POINTER(c_int)]
			self.dt.TTSENG_GetMode.restype = c_int

			self.dt.TTSENG_GetVoice.argtypes = [c_int, POINTER(c_int), POINTER(c_int)]
			self.dt.TTSENG_GetVoice.restype = c_int

			self.dt.TTSENG_SetMode.argtypes = [c_int, c_int, c_int, c_int]
			self.dt.TTSENG_SetMode.restype = c_int

			self.dt.TTSENG_GetProsodyOptions.argtypes = [c_int, POINTER(c_int), POINTER(c_int), POINTER(c_int), POINTER(c_int)]
			self.dt.TTSENG_GetProsodyOptions.restype = c_int

			self.dt.TTSENG_SetProsodyOptions.argtypes = [c_int, c_int, c_int, c_int, c_int]
			self.dt.TTSENG_SetProsodyOptions.restype = c_int

			self.dt.TTSENG_SetVoice.argtypes = [c_int, c_int, c_int]
			self.dt.TTSENG_SetVoice.restype = c_int

			self.dt.TTSENG_PauseText.argtypes = [c_int]
			self.dt.TTSENG_PauseText.restype = c_int

			self.dt.TTSENG_PlayText.argtypes = [c_int, c_char_p, c_bool]
			self.dt.TTSENG_PlayText.restype = c_int

			self.dt.TTSENG_ResumeText.argtypes = [c_int]
			self.dt.TTSENG_ResumeText.restype = c_int

			self.dt.TTSENG_StopText.argtypes = [c_int]
			self.dt.TTSENG_StopText.restype = c_int
		except Exception as e:
			logging.error(f"Erro ao carregar DeltaTalk DLL: {e}")
			raise RuntimeError("Erro ao carregar a DeltaTalk DLL.")

		# Inicializa o sistema TTS e armazena a instância
		try:
			logging.debug("Chamando TTSENG_Init com parâmetros: False, None, DSP_MULTIMEDIA")
			self.instancia = self.dt.TTSENG_Init(False, None, self.DSP_MULTIMEDIA)
			logging.debug(f"Resultado da inicialização do DeltaTalk TTS (instância): {self.instancia}")
			if self.instancia <= 0:
				error_codes = {
					-1: "TTS_NOT_INITIALIZED",
					-4: "TTS_DSP_INIT_ERROR",
					-7: "TTS_INIT_ENGINE_ERROR",
					-13: "TTS_WAVEOUT_NOT_AVAILABLE",
					-103: "TTS_DSP_NOT_FOUND",
					-106: "TTS_NO_LICENSE"
				}
				error_message = error_codes.get(self.instancia, f"Código de erro desconhecido: {self.instancia}")
				logging.error(f"Falha ao inicializar DeltaTalk TTS. {error_message}")
				raise RuntimeError(f"Falha ao inicializar DeltaTalk TTS. {error_message}")

			logging.debug(f"DeltaTalk instância inicializada com sucesso: {self.instancia}")
			
			# Configurar licença (se necessário)
			license_key = "DTK-300-29314-34564-04464-731"  # Chave de exemplo
			result = self.dt.TTSENG_SetLicense(license_key.encode())
			logging.debug(f"Resultado da configuração da licença: {result}")
			
			# Configurar voz inicial
			self.dt.TTSENG_SetVoice(self.instancia, self._voice, 1)
			
			# Configurar opções de prosódia
			self.dt.TTSENG_SetProsodyOptions(self.instancia, 50, 350, 100, self.MODEL_HHS)
			
			# Configurar modo inicial
			self.dt.TTSENG_SetMode(self.instancia, self._rate, self._volume, self._pitch)

		except Exception as e:
			logging.error(f"Erro durante a inicialização do DeltaTalk TTS: {e}")
			raise RuntimeError(f"Erro durante a inicialização do DeltaTalk TTS: {e}")

	def speak(self, speechSequence):
		textParts = []
		for item in speechSequence:
			if isinstance(item, str):
				textParts.append(item)
			elif isinstance(item, IndexCommand):
				self._lastIndex = item.index
			elif isinstance(item, PitchCommand):
				self.dt.TTSENG_SetMode(self.instancia, self._rate, self._volume, int(self._pitch * item.multiplier))
			elif isinstance(item, RateCommand):
				self.dt.TTSENG_SetMode(self.instancia, item.newValue, self._volume, self._pitch)
			elif isinstance(item, VolumeCommand):
				self.dt.TTSENG_SetMode(self.instancia, self._rate, item.newValue, self._pitch)

		text = "".join(textParts)
		if text:
			result = self.dt.TTSENG_PlayText(self.instancia, text.encode(), True)
			if result != 0:  # TTS_SUCCESSFUL
				log.error(f"Erro ao reproduzir texto. Código: {result}")

		self.dt.TTSENG_SetMode(self.instancia, self._rate, self._volume, self._pitch)
		_thread.start_new_thread(self._speechMonitor, (self._lastIndex, 0.1))

		def cancel(self):
			self.dt.TTSENG_StopText(self.instancia)

	def pause(self, switch):
		if switch:
			self.dt.TTSENG_PauseText(self.instancia)
		else:
			self.dt.TTSENG_ResumeText(self.instancia)

	def terminate(self):
		try:
			self.cancel()
			self.dt.TTSENG_Close(self.instancia)
		except:
			pass

#	def _get_voice(self):
#		return self._voice

#	def _set_voice(self, value):
#		self._voice = value
#		self.dt.TTSENG_SetVoice(self.instancia, self._voice, 1)

#	voice = property(_get_voice, _set_voice)

#	def _get_rate(self):
#		return self._rate

#	def _set_rate(self, value):
#		self._rate = value
#		self.dt.TTSENG_SetMode(self.instancia, self._rate, self._volume, self._pitch)

#	def _get_pitch(self):
#		return self._pitch

#	def _set_pitch(self, value):
#		self._pitch = value
#		self.dt.TTSENG_SetMode(self.instancia, self._rate, self._volume, self._pitch)

#	def _get_volume(self):
#		return self._volume

#	def _set_volume(self, value):
#		self._volume = value
#		self.dt.TTSENG_SetMode(self.instancia, self._rate, self._volume, self._pitch)

#	rate = property(_get_rate, _set_rate)
#	pitch = property(_get_pitch, _set_pitch)
#	volume = property(_get_volume, _set_volume)

	def _get_lastIndex(self):
		return self._lastIndex

	def _speechMonitor(self, idx, delay):
		while self.dt.TTSENG_PlayText(self.instancia, b"", True) == -2:  # TTS_BUSY
			time.sleep(delay)
		if idx != 0:
			synthIndexReached.notify(synth=self, index=idx)
		else:
			synthDoneSpeaking.notify(synth=self)

	@property
	def _get_lastIndex(self):

		return self._lastIndex

	def availableVoices(self):
		return [VoiceInfo(id=str(voice_info["index"]), name=voice_info["name"], language="pt_BR") for voice_info in self._voices.values()]