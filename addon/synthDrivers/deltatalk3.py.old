import ctypes
from ctypes import *
import synthDriverHandler
from synthDriverHandler import synthDoneSpeaking, SynthDriver, synthIndexReached, VoiceInfo
import logging
import time
from speech.commands import IndexCommand, PitchCommand, RateCommand, VolumeCommand

# Dicionário de erros do DeltaTalk
ERROR_CODES = {
    0: "TTS_SUCCESSFUL",
    -1: "TTS_NOT_INITIALIZED",
    -5: "TTS_FILE_OPEN_ERROR",
    -7: "TTS_INIT_ENGINE_ERROR",
    -13: "TTS_WAVEOUT_NOT_AVAILABLE",
    -103: "TTS_DSP_NOT_FOUND",
    -106: "TTS_NO_LICENSE",
}

# Modos de DSP suportados
DSP_MODES = {
    "MULTIMEDIA": 0,
    "TELEPHONY": 1
}

# Vozes disponíveis
VOICES = {
    "br1": "DeltaTalk - Marcelo (16 kHz)",
    "br3": "DeltaTalk - José (22 kHz)",  # Corrigido: José estava invertido
    "br2": "DeltaTalk - Paula (22 kHz)"  # Corrigido: Paula estava invertida
}

VOICE_MAP = {
    "br1": 0,  # Marcelo
    "br3": 1,  # José (corrigido)
    "br2": 2   # Paula (corrigido)
}

# Multiplicador ajustado para converter valores corretamente
DT_MULTIPLIER = 19 / 100  # 100 (NVDA) → 19 (DeltaTalk), mínimo 1

def convert_nvda_value(value):
    """Converte um valor da escala do NVDA (0-100) para a escala do DeltaTalk (1-19)."""
    return max(1, min(19, int(value * DT_MULTIPLIER)))  # Evita ultrapassar o limite

class SynthDriver(synthDriverHandler.SynthDriver):
    name = "deltatalk"
    description = _("DeltaTalk")
    language = "pt-BR"

    supportedSettings = [
        SynthDriver.VoiceSetting(),
        SynthDriver.RateSetting(),
        SynthDriver.PitchSetting(),
        SynthDriver.VolumeSetting(),
    ]

    supportedCommands = {
        IndexCommand,
        RateCommand,
        PitchCommand,
        VolumeCommand,
    }

    supportedNotifications = {synthIndexReached, synthDoneSpeaking}

    @classmethod
    def check(cls):
        """Verifica se a DLL do DeltaTalk está presente e válida."""
        try:
            dll = ctypes.WinDLL("Dtalk32T.dll")
            if hasattr(dll, "TTSENG_InitEx"):
                logging.debug("DLL DeltaTalk carregada e válida.")
                return True
            else:
                logging.error("DLL DeltaTalk encontrada, mas função TTSENG_InitEx ausente.")
                return False
        except OSError:
            logging.error("DLL DeltaTalk não encontrada.")
            return False

    def __init__(self):
        super(SynthDriver, self).__init__()
        self._rate = 50
        self._pitch = 50
        self._volume = 100
        self._voice = "br1"
        self._lastIndex = 0
        self.instancia = None

        try:
            self.dt = ctypes.WinDLL("Dtalk32T.dll")
        except Exception as e:
            logging.error(f"Erro ao carregar DLL DeltaTalk: {e}")
            self.dt = None
            return

        self._initialize_tts()

    def _initialize_tts(self):
        """Inicializa o sintetizador DeltaTalk."""
        if not self.dt:
            logging.error("Tentativa de inicializar o TTS sem a DLL carregada.")
            return False

        logging.debug("Iniciando inicialização do TTS")
        try:
            self.instancia = self.dt.TTSENG_InitEx(False, None, DSP_MODES["MULTIMEDIA"], b"br1")
            if self.instancia <= 0:
                logging.error(f"Erro ao inicializar o TTS: {ERROR_CODES.get(self.instancia, 'Erro desconhecido')}")
                self.instancia = None
                return False
            logging.debug(f"DeltaTalk inicializado. Instância: {self.instancia}")
            return True
        except Exception as e:
            logging.error(f"Erro ao inicializar o TTS: {e}")
            self.instancia = None
            return False

    def speak(self, speechSequence):
        """Reproduz um texto no sintetizador."""
        if not self.instancia:
            logging.error("Tentativa de fala sem instância inicializada.")
            return

        concatenated_text = " ".join(item for item in speechSequence if isinstance(item, str)).strip()

        if concatenated_text:
            try:
                encoded_text = concatenated_text.encode("cp1252")
                play_result = self.dt.TTSENG_PlayText(self.instancia, c_char_p(encoded_text), True)

                if play_result == -2:
                    append_result = self.dt.TTSENG_AppendText(self.instancia, c_char_p(encoded_text))
                    if append_result != 0:
                        logging.error(f"Erro ao anexar texto: {ERROR_CODES.get(append_result, 'Erro desconhecido')} ({append_result})")
                elif play_result != 0:
                    logging.error(f"Erro ao falar texto: {ERROR_CODES.get(play_result, 'Erro desconhecido')} ({play_result})")
                else:
                    logging.info(f"Texto falado com sucesso: {concatenated_text}")

            except Exception as e:
                logging.error(f"Erro ao falar texto: {e}")

    def _set_rate(self, value):
        """Define a velocidade da fala."""
        self._rate = convert_nvda_value(value)
        if self.instancia:
            self.dt.TTSENG_SetMode(self.instancia, self._rate, self._volume, self._pitch)
            logging.info(f"Velocidade configurada para {self._rate} (convertido de {value})")

    def _set_pitch(self, value):
        """Define o tom da voz."""
        self._pitch = convert_nvda_value(value)
        if self.instancia:
            self.dt.TTSENG_SetMode(self.instancia, self._rate, self._volume, self._pitch)
            logging.info(f"Tom configurado para {self._pitch} (convertido de {value})")

    def _set_volume(self, value):
        """Define o volume da fala."""
        self._volume = convert_nvda_value(value)
        if self.instancia:
            self.dt.TTSENG_SetMode(self.instancia, self._rate, self._volume, self._pitch)
            logging.info(f"Volume configurado para {self._volume} (convertido de {value})")

    @property
    def voice(self):
        return self._voice

    @voice.setter
    def voice(self, value):
        """Define a voz do sintetizador."""
        if value in VOICES:
            self._voice = value
            if self.instancia:
                voice_id = VOICE_MAP[value]
                self.dt.TTSENG_SetVoice(self.instancia, voice_id, 10)
                logging.info(f"Voz alterada para {VOICES[value]}")

    @property
    def availableVoices(self):
        return {
            key: VoiceInfo(
                id=key,
                displayName=VOICES[key],
            ) for key in VOICES
        }

    def pause(self, switch):
        if switch:
            self.dt.TTSENG_PauseText(self.instancia)
        else:
            self.dt.TTSENG_ResumeText(self.instancia)

    def cancel(self):
        if self.instancia:
            self.dt.TTSENG_StopText(self.instancia)

    def terminate(self):
        if self.instancia:
            self.cancel()
            try:
                self.dt.TTSENG_Close(self.instancia)
            except Exception as e:
                logging.error(f"Erro ao fechar o sintetizador: {e}")
            finally:
                self.instancia = None
