# synthDrivers/deltatalk.py
# A part of NonVisual Desktop Access (NVDA)
# Copyright (C) 2006-2014 NV Access Limited
# This file is covered by the GNU General Public License.
# See the file COPYING for more details.

import synthDriverHandler
import speech
from synthDriverHandler import SynthDriver, VoiceInfo, synthIndexReached, synthDoneSpeaking
from ctypes import *
import os.path
import threading
import time
from collections import OrderedDict
import _thread
from time import sleep
import logging

from speech.commands import (
    IndexCommand,
    PitchCommand,
    RateCommand,
    VolumeCommand,
)

class SynthDriver(synthDriverHandler.SynthDriver):
    """DeltaTalk Synthesizer driver for NVDA."""
    name = "deltatalk"
    # Translators: Description for a speech synthesizer for NVDA.
    description = _("DeltaTalk")

    #   Constantes de vozes do sintetizador
    VOICE_MASC1 = 0
    VOICE_MASC2 = 1
    VOICE_FEM1 = 2

    _voices = OrderedDict()
    _voices["VOICE_MASC1"] = {"name": "DeltaTalk - Marcelo (16 kHz)", "index": 0}
    _voices["VOICE_MASC2"] = {"name": "DeltaTalk - José (22 kHz)", "index": 1}
    _voices["VOICE_FEM1"] = {"name": "DeltaTalk - Paula (22 kHz)", "index": 2}

    instancia = 0

    @classmethod
    def check(cls):
        dtPath = os.path.abspath(os.path.join(os.path.dirname(__file__), 'deltatalk', 'Dtalk32t.dll'))
        logging.debug(f"DeltaTalk DLL Path: {dtPath}")
        exists = os.path.exists(dtPath)
        logging.debug(f"DeltaTalk DLL Exists: {exists}")
        return exists

    supportedSettings = [
        SynthDriver.PitchSetting(),
        SynthDriver.RateSetting(),
        SynthDriver.VolumeSetting(),
#        SynthDriver.VoiceSetting(),
    ]

    supportedCommands = {
        IndexCommand,
        PitchCommand,
        RateCommand,
        VolumeCommand,
    }

    supportedNotifications = {synthIndexReached, synthDoneSpeaking}

    def __init__(self):
        self._rate = 10
        self._pitch = 10
        self._volume = 20
#        self.voice = self._voices["VOICE_MASC1"]
        self.voice = self.VOICE_MASC1
        self._lastIndex = 0

        dtPath = os.path.abspath(os.path.join(os.path.dirname(__file__), 'deltatalk', 'Dtalk32t.dll'))
        if not os.path.exists(dtPath):
            raise RuntimeError("DeltaTalk DLL não encontrada no caminho especificado.")
        
        self.dt = windll.LoadLibrary(dtPath)
        self.instancia = self.dt.TTSENG_Init(False, None, 16000 if self._voices == 0 else 22050)
        self.dt.TTSENG_SetVoice(self.instancia, self.voice, 1)
        self.dt.TTSENG_SetMode(self.instancia, self._rate, self._volume, self._pitch)

    def speak(self, speechSequence):
        self._lastIndex = 0
        s = ""
        chpitch = False
        for item in speechSequence:
            if isinstance(item, str):
                s += " " + item
            elif isinstance(item, IndexCommand):
                self._lastIndex = item.index
            elif isinstance(item, PitchCommand):
                if not chpitch:
                    chpitch = True
                    self.dt.TTSENG_SetMode(self.instancia, self._rate, self._volume, int(self._pitch * item.multiplier))
            elif isinstance(item, RateCommand):
                    self.dt.TTSENG_SetMode(self.instancia, item.rate, self._volume, self._pitch)
            elif isinstance(item, VolumeCommand):
                self.dt.TTSENG_SetMode(self.instancia, self._rate, item.volume, self._pitch)

        if s:
            self.dt.TTSENG_PlayText(self.instancia, s.strip().encode(), true)
        self.dt.TTSENG_SetMode(self.instancia, self._rate, self._volume, self._pitch)
        _thread.start_new_thread(self._speechMonitor, (self._lastIndex, 0.1,))

    def cancel(self):
        self.dt.TTSENG_StopText(self.instancia)

    def _get_rate(self):
        return self._rate

    def _get_index(self):
        return self._lastIndex

    def _set_rate(self, value):
        self._rate = int(value)
        self.dt.TTSENG_SetMode(self.instancia, self._rate, self._volume, self._pitch)

    def _get_pitch(self):
        return self._pitch

    def _set_pitch(self, value):
        self._pitch = int(value)
        self.dt.TTSENG_SetMode(self.instancia, self._rate, self._volume, self._pitch)

    def _get_volume(self):
        return self._volume

    def _set_volume(self, value):
        self._volume = int(value)
        self.dt.TTSENG_SetMode(self.instancia, self._rate, self._volume, self._pitch)

    def _get_voice(self):
        return self._voice

#    def _set_voice(self, value):
#        self._voice = self._voices.get(value, 0)
#        self.dt.TTSENG_SetVoice(self.instancia, self._voice, 1)

    def _speechMonitor(self, idx, delay):
        while   self.dt.TTSENG_PlayText(self.instancia, "00", true)==-2:   #   Apenas para verificar se o retorno é -2 (TTS_BUSY)
            time.sleep(delay)
        if idx != 0:
            synthIndexReached.notify(synth=self, index=idx)
        else:
            synthDoneSpeaking.notify(synth=self)

    @property
    def availableVoices(self):
        return [
            VoiceInfo(
                id=str(index),
                name=voice_info["name"],
                languages=["pt_BR"],
                gender="male" if "MASC" in name else "female",
                age="adult"
            )
            for name, voice_info in self._voices.items()
        ]
