import synthDriverHandler
import speech
from synthDriverHandler import SynthDriver, VoiceInfo, synthIndexReached, synthDoneSpeaking
import ctypes
from ctypes import *
import os.path
import threading
import time
from collections import OrderedDict
import _thread
from logHandler import log
import logging

from speech.commands import (
    IndexCommand,
    PitchCommand,
    RateCommand,
    VolumeCommand,
)

class SynthDriver(synthDriverHandler.SynthDriver):
    """DeltaTalk Synthesizer driver for NVDA."""
    name = "deltatalk"
    description = _("DeltaTalk")

    # Constantes de vozes do sintetizador
    VOICE_MASC1 = 0
    VOICE_MASC2 = 1
    VOICE_FEM1 = 2

    # Constantes DSP_Freq
    DSP_MULTIMEDIA = 0  # Corrigido para corresponder ao valor em DTalk32.h
    DSP_TELEPHONY = 1

    # Constantes de vozes e prosódia
    MODEL_NORMAL = 0
    MODEL_HHS = 1

    EMP_NORMAL = 0
    EMP_STRESS = 1

    # Códigos de erro
    TTS_SUCCESSFUL = 0
    TTS_NOT_INITIALIZED = -1
    TTS_BUSY = -2
    TTS_BAD_COMMAND = -3
    TTS_DSP_INIT_ERROR = -4
    TTS_FILE_OPEN_ERROR = -5
    TTS_FILE_WRITE_ERROR = -6
    TTS_INIT_ENGINE_ERROR = -7
    TTS_MEM_ALLOC_ERROR = -8
    TTS_WAVEOUT_BUSY = -9
    TTS_WAVEOUT_OPEN_ERROR = -10
    TTS_WAVEOUT_WRITE_ERROR = -11
    TTS_WAVEOUT_FORMAT_ERROR = -12
    TTS_WAVEOUT_NOT_AVAILABLE = -13
    TTS_WAVEOUT_ERROR = -14
    TTS_WAVEOUT_MEM_ALLOC_ERROR = -15
    TTS_VALUE_OUT_OF_RANGE = -16
    TTS_PCM_FINISHED = -17
    TTS_MBR_ERROR = -100
    TTS_DSP_NOT_FOUND = -103
    TTS_PROSODY_INIT_ERROR = -104
    TTS_NO_LICENSE = -106

    _voices = OrderedDict()
    _voices["VOICE_MASC1"] = {"name": "DeltaTalk - Marcelo (16 kHz)", "index": VOICE_MASC1}
    _voices["VOICE_MASC2"] = {"name": "DeltaTalk - José (22 kHz)", "index": VOICE_MASC2}
    _voices["VOICE_FEM1"] = {"name": "DeltaTalk - Paula (22 kHz)", "index": VOICE_FEM1}

    instancia = 0

    @classmethod
    def check(cls):
        dtPath = os.path.join(os.path.dirname(__file__), 'deltatalk\\Dtalk32t.dll')
        logging.debug(f"DeltaTalk DLL Path: {dtPath}")
        exists = os.path.exists(dtPath)
        logging.debug(f"DeltaTalk DLL Exists: {exists}")
        return exists

    supportedSettings = [
        SynthDriver.PitchSetting(),
        SynthDriver.RateSetting(),
        SynthDriver.VolumeSetting(),
        SynthDriver.VoiceSetting(),
    ]

    supportedCommands = {
        IndexCommand,
        PitchCommand,
        RateCommand,
        VolumeCommand,
    }

    supportedNotifications = {synthIndexReached, synthDoneSpeaking}

    def __init__(self):
        self._rate = 10
        self._pitch = 10
        self._volume = 20
        self._voice = self.VOICE_MASC1
        self._lastIndex = 0

        dtPath = os.path.join(os.path.dirname(__file__), 'deltatalk\\Dtalk32t.dll')
        if not os.path.exists(dtPath):
            raise RuntimeError("DeltaTalk DLL não encontrada no caminho especificado.")
        logging.debug(f"DeltaTalk DLL encontrada no caminho: {dtPath}")

        try:
            self.dt = ctypes.windll.LoadLibrary(dtPath)  # Carregue a DLL
            logging.debug(f"DeltaTalk DLL carregada: {self.dt}")

            # Definindo protótipos e parâmetros para as funções da DLL
            self.dt.TTSENG_SetLicense.argtypes = [c_char_p]
            self.dt.TTSENG_SetLicense.restype = c_int

            CALLBACK_TYPE = WINFUNCTYPE(None)  # Definir o tipo de função de callback, se necessário

            self.dt.TTSENG_Init.argtypes = [c_bool, c_void_p, c_int]
            self.dt.TTSENG_Init.restype = c_int

            self.dt.TTSENG_InitEx.argtypes = [c_bool, c_void_p, c_int, c_char_p]
            self.dt.TTSENG_InitEx.restype = c_int

            self.dt.TTSENG_Close.argtypes = [c_int]
            self.dt.TTSENG_Close.restype = c_int

            self.dt.TTSENG_GetMode.argtypes = [c_int, POINTER(c_int), POINTER(c_int), POINTER(c_int)]
            self.dt.TTSENG_GetMode.restype = c_int

            self.dt.TTSENG_GetVoice.argtypes = [c_int, POINTER(c_int), POINTER(c_int)]
            self.dt.TTSENG_GetVoice.restype = c_int

            self.dt.TTSENG_SetMode.argtypes = [c_int, c_int, c_int, c_int]
            self.dt.TTSENG_SetMode.restype = c_int

            self.dt.TTSENG_GetProsodyOptions.argtypes = [c_int, POINTER(c_int), POINTER(c_int), POINTER(c_int), POINTER(c_int)]
            self.dt.TTSENG_GetProsodyOptions.restype = c_int

            self.dt.TTSENG_SetProsodyOptions.argtypes = [c_int, c_int, c_int, c_int, c_int]
            self.dt.TTSENG_SetProsodyOptions.restype = c_int

            self.dt.TTSENG_SetVoice.argtypes = [c_int, c_int, c_int]
            self.dt.TTSENG_SetVoice.restype = c_int

            self.dt.TTSENG_PauseText.argtypes = [c_int]
            self.dt.TTSENG_PauseText.restype = c_int

            self.dt.TTSENG_PlayText.argtypes = [c_int, c_char_p, c_bool]
            self.dt.TTSENG_PlayText.restype = c_int

            self.dt.TTSENG_ResumeText.argtypes = [c_int]
            self.dt.TTSENG_ResumeText.restype = c_int

            self.dt.TTSENG_StopText.argtypes = [c_int]
            self.dt.TTSENG_StopText.restype = c_int
        except Exception as e:
            logging.error(f"Erro ao carregar DeltaTalk DLL: {e}")
            raise RuntimeError("Erro ao carregar a DeltaTalk DLL.")
        
        # Inicializa o sistema TTS e armazena a instância
        try:
            logging.debug("Chamando TTSENG_Init com parâmetros: False, None, DSP_MULTIMEDIA")
            self.instancia = self.dt.TTSENG_Init(False, None, self.DSP_MULTIMEDIA)
            logging.debug(f"Resultado da inicialização do DeltaTalk TTS (instância): {self.instancia}")
            if self.instancia <= 0:
                logging.error(f"Falha ao inicializar DeltaTalk TTS. Código de erro: {self.instancia}")
                raise RuntimeError(f"Falha ao inicializar DeltaTalk TTS. Código de erro: {self.instancia}")
        except Exception as e:
            logging.error(f"Erro durante a inicialização do DeltaTalk TTS: {e}")
            raise RuntimeError(f"Erro durante a inicialização do DeltaTalk TTS: {e}")
        
        logging.debug(f"DeltaTalk instância inicializada com sucesso: {self.instancia}")
        try:
            logging.debug(f"Definindo voz com parâmetros: instancia={self.instancia}, voice={self._voice}, 1")
            self.dt.TTSENG_SetVoice(self.instancia, self._voice, 1)
            logging.debug(f"Definindo modo com parâmetros: instancia={self.instancia}, rate={self._rate}, volume={self._volume}, pitch={self._pitch}")
            self.dt.TTSENG_SetMode(self.instancia, self._rate, self._volume, self._pitch)
        except Exception as e:
            logging.error(f"Erro ao definir voz ou modo do DeltaTalk TTS: {e}")
            raise RuntimeError(f"Erro ao definir voz ou modo do DeltaTalk TTS: {e}")

    def speak(self, speechSequence):
        self._lastIndex = 0
        s = ""
        chpitch = False
        for item in speechSequence:
            if isinstance(item, str):
                s += " " + item
            elif isinstance(item, IndexCommand):
                self._lastIndex = item.index
            elif isinstance(item, PitchCommand):
                if not chpitch:
                    chpitch = True
                    self.dt.TTSENG_SetMode(self.instancia, self._rate, self._volume, int(self._pitch * item.multiplier))
            elif isinstance(item, RateCommand):
                self.dt.TTSENG_SetMode(self.instancia, item.rate, self._volume, self._pitch)
            elif isinstance(item, VolumeCommand):
                self.dt.TTSENG_SetMode(self.instancia, self._rate, item.volume, self._pitch)

        if s:
            self.dt.TTSENG_PlayText(self.instancia, s.strip().encode(), True)
        self.dt.TTSENG_SetMode(self.instancia, self._rate, self._volume, self._pitch)
        _thread.start_new_thread(self._speechMonitor, (self._lastIndex, 0.1,))

    def cancel(self):
        self.dt.TTSENG_StopText(self.instancia)

    def _get_rate(self):
        return self._rate

    def _get_index(self):
        return self._lastIndex

    def _set_rate(self, value):
        self._rate = int(value)
        self.dt.TTSENG_SetMode(self.instancia, self._rate, self._volume, self._pitch)

    def _get_pitch(self):
        return self._pitch

    def _set_pitch(self, value):
        self._pitch = int(value)
        self.dt.TTSENG_SetMode(self.instancia, self._rate, self._volume, self._pitch)

    def _get_volume(self):
        return self._volume

    def _set_volume(self, value):
        self._volume = int(value)
        self.dt.TTSENG_SetMode(self.instancia, self._rate, self._volume, self._pitch)

    def _get_voice(self):
        return self._voice

    def _set_voice(self, value):
       self._voice = value
       self.dt.TTSENG_SetVoice(self.instancia, self._voice, 1)

    def _speechMonitor(self, idx, delay):
        while self.dt.TTSENG_PlayText(self.instancia, "00", True) == -2:  # Apenas para verificar se o retorno é -2 (TTS_BUSY)
            time.sleep(delay)
        if idx != 0:
            synthIndexReached.notify(synth=self, index=idx)
        else:
            synthDoneSpeaking.notify(synth=self)

@property
def availableVoices(self):
    return [
        VoiceInfo(
            id=str(voice_info["index"]),
            name=voice_info["name"],
            language="pt_BR",
            gender="male" if "MASC" in voice_info["name"] else "female"
        )
        for voice_info in self._voices.values()
    ]